---
layout: post
title: 深入研究blocks语法
keywords: 语法
category: 语法
tags: [语法]
---

我举一个简单的例子来定义和使用block

    void (^block1)(void) = ^void (void){
        NSLog(@"hello");
    };
    block1();
    
是不是很简单啊！么得什么难度嘛！

###block的存在样式
*.h*

  typedef `returnType`(^`name`)(`arguments`);

    typedef void(^block2)(void);
    typedef void(^block3)(NSInteger index);
    
    -(void)doSomethingWithBlock:(block2)block;
    
    @property (nonatomic, strong) dispatch_block_t block4;

*.m*

    self.block4 = ^{
        NSLog(@"hello");
    };
    
    self.block4();
    
    [self doSomethingWithBlock:^{
        NSLog(@"hello");
    }];
    
    -(void)doSomethingWithBlock:(block2)block{
        block();
    }
    
###block的用处
首先我们可以回想下ASI网络访问处理异步回调的方法，首先得设置当前使用类的代理，然后写两个回调方法

    -(void)requestFinished:(ASIHTTPRequest *)req{

    }

    -(void)requestFailed:(ASIHTTPRequest *)req{

    }
    
如果当前类处理请求多的话，那么可能需要设置不同的回调方法以区分

    [request setDidFinishSelector:@selector(topSecretFetchComplete:)];
	[request setDidFailSelector:@selector(topSecretFetchFailed:)];
	
好烦啊，好多个方法👀都看不清了。我们来改一改吧。建一个ASIHTTPRequest的分类
*ASIHTTPRequest+blockAddtion.h*

    #import "ASIHTTPRequest.h"
    typedef void (^requestSuccessHandler)(ASIHTTPRequest *request);
    typedef void (^requestFailedHandler)(ASIHTTPRequest *request);

    @interface ASIHTTPRequest (blockAddtion)<ASIHTTPRequestDelegate>

    -(void)startAsynchronousWithSuccess:(requestSuccessHandler)success failed:(requestFailedHandler)failed;

    @end
    
*ASIHTTPRequest+blockAddtion.m*

    #import "ASIHTTPRequest+blockAddtion.h"
	#import <objc/runtime.h>
		
	static NSString * const handlerRunTimeAccosiationKey1 = @"requestSuccessHandler";
	static NSString * const handlerRunTimeAccosiationKey2 = @"requestFailedHandler";
		
	@implementation ASIHTTPRequest (blockAddtion)
		
	-(void)startAsynchronousWithSuccess:(requestSuccessHandler)success failed:(requestFailedHandler)failed{
	    objc_setAssociatedObject(self, (__bridge const void *)(handlerRunTimeAccosiationKey1), success, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
		objc_setAssociatedObject(self, (__bridge const void *)(handlerRunTimeAccosiationKey2), failed, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
		    
		[self setDelegate:self];
    }
		
	-(void)dealloc{
	    objc_removeAssociatedObjects(handlerRunTimeAccosiationKey1);
	    objc_removeAssociatedObjects(handlerRunTimeAccosiationKey2);
	    [super dealloc];
	}
	
	-(void)requestFinished:(ASIHTTPRequest *)req{
	    requestSuccessHandler completionHandler = objc_getAssociatedObject(self, (__bridge const void *)(handlerRunTimeAccosiationKey1));
	    if(completionHandler){
	        completionHandler(req);
	    }
	}
	
	-(void)requestFailed:(ASIHTTPRequest *)req{
	    requestFailedHandler completionHandler = objc_getAssociatedObject(self, (__bridge const void *)(handlerRunTimeAccosiationKey2));
	    if(completionHandler){
	        completionHandler(req);
	    }
	}
	
	@end


那么现在我们在数据请求的时候就可以这样写

    [request startAsynchronousWithSuccess:^(ASIHTTPRequest *request) {
        
    } failed:^(ASIHTTPRequest *request) {
        
    }];
    
请求成功或者失败都在里面写就好啦！
